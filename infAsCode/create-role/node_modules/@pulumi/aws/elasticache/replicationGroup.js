"use strict";
// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReplicationGroup = void 0;
const pulumi = require("@pulumi/pulumi");
const utilities = require("../utilities");
/**
 * Provides an ElastiCache Replication Group resource.
 *
 * For working with a [Memcached cluster](https://docs.aws.amazon.com/AmazonElastiCache/latest/mem-ug/WhatIs.html) or a
 * [single-node Redis instance (Cluster Mode Disabled)](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/WhatIs.html),
 * see the `aws.elasticache.Cluster` resource.
 *
 * > **Note:** When you change an attribute, such as `engineVersion`, by
 * default the ElastiCache API applies it in the next maintenance window. Because
 * of this, this provider may report a difference in its planning phase because the
 * actual modification has not yet taken place. You can use the
 * `applyImmediately` flag to instruct the service to apply the change
 * immediately. Using `applyImmediately` can result in a brief downtime as
 * servers reboots.
 * See the AWS Documentation on
 * [Modifying an ElastiCache Cache Cluster](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Clusters.Modify.html)
 * for more information.
 *
 * > **Note:** Any attribute changes that re-create the resource will be applied immediately, regardless of the value of `applyImmediately`.
 *
 * > **Note:** Be aware of the terminology collision around "cluster" for `aws.elasticache.ReplicationGroup`. For example, it is possible to create a ["Cluster Mode Disabled [Redis] Cluster"](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Clusters.Create.CON.Redis.html). With "Cluster Mode Enabled", the data will be stored in shards (called "node groups"). See [Redis Cluster Configuration](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/cluster-create-determine-requirements.html#redis-cluster-configuration) for a diagram of the differences. To enable cluster mode, use a parameter group that has cluster mode enabled. The default parameter groups provided by AWS end with ".cluster.on", for example `default.redis6.x.cluster.on`.
 *
 * ## Example Usage
 * ### Redis Cluster Mode Disabled
 *
 * To create a single shard primary with single read replica:
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = new aws.elasticache.ReplicationGroup("example", {
 *     automaticFailoverEnabled: true,
 *     availabilityZones: [
 *         "us-west-2a",
 *         "us-west-2b",
 *     ],
 *     nodeType: "cache.m4.large",
 *     numberCacheClusters: 2,
 *     parameterGroupName: "default.redis3.2",
 *     port: 6379,
 *     replicationGroupDescription: "test description",
 * });
 * ```
 *
 * You have two options for adjusting the number of replicas:
 *
 * * Adjusting `numberCacheClusters` directly. This will attempt to automatically add or remove replicas, but provides no granular control (e.g. preferred availability zone, cache cluster ID) for the added or removed replicas. This also currently expects cache cluster IDs in the form of `replication_group_id-00#`.
 * * Otherwise for fine grained control of the underlying cache clusters, they can be added or removed with the `aws.elasticache.Cluster` resource and its `replicationGroupId` attribute. In this situation, you will need to utilize [`ignoreChanges`](https://www.pulumi.com/docs/intro/concepts/programming-model/#ignorechanges) to prevent perpetual differences with the `numberCacheCluster` attribute.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = new aws.elasticache.ReplicationGroup("example", {
 *     automaticFailoverEnabled: true,
 *     availabilityZones: [
 *         "us-west-2a",
 *         "us-west-2b",
 *     ],
 *     replicationGroupDescription: "test description",
 *     nodeType: "cache.m4.large",
 *     numberCacheClusters: 2,
 *     parameterGroupName: "default.redis3.2",
 *     port: 6379,
 * });
 * let replica: aws.elasticache.Cluster | undefined;
 * if (1 == true) {
 *     replica = new aws.elasticache.Cluster("replica", {replicationGroupId: example.id});
 * }
 * ```
 * ### Redis Cluster Mode Enabled
 *
 * To create two shards with a primary and a single read replica each:
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const baz = new aws.elasticache.ReplicationGroup("baz", {
 *     automaticFailoverEnabled: true,
 *     clusterMode: {
 *         numNodeGroups: 2,
 *         replicasPerNodeGroup: 1,
 *     },
 *     nodeType: "cache.t2.small",
 *     parameterGroupName: "default.redis3.2.cluster.on",
 *     port: 6379,
 *     replicationGroupDescription: "test description",
 * });
 * ```
 *
 * > **Note:** We currently do not support passing a `primaryClusterId` in order to create the Replication Group.
 *
 * > **Note:** Automatic Failover is unavailable for Redis versions earlier than 2.8.6,
 * and unavailable on T1 node types. For T2 node types, it is only available on Redis version 3.2.4 or later with cluster mode enabled. See the [High Availability Using Replication Groups](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Replication.html) guide
 * for full details on using Replication Groups.
 * ### Creating a secondary replication group for a global replication group
 *
 * A Global Replication Group can have one one two secondary Replication Groups in different regions. These are added to an existing Global Replication Group.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const primary = new aws.elasticache.ReplicationGroup("primary", {
 *     replicationGroupDescription: "primary replication group",
 *     engine: "redis",
 *     engineVersion: "5.0.6",
 *     nodeType: "cache.m5.large",
 *     numberCacheClusters: 1,
 * }, {
 *     provider: aws.other_region,
 * });
 * const example = new aws.elasticache.GlobalReplicationGroup("example", {
 *     globalReplicationGroupIdSuffix: "example",
 *     primaryReplicationGroupId: primary.id,
 * }, {
 *     provider: aws.other_region,
 * });
 * const secondary = new aws.elasticache.ReplicationGroup("secondary", {
 *     replicationGroupDescription: "secondary replication group",
 *     globalReplicationGroupId: example.globalReplicationGroupId,
 *     numberCacheClusters: 1,
 * });
 * ```
 *
 * ## Import
 *
 * ElastiCache Replication Groups can be imported using the `replication_group_id`, e.g.,
 *
 * ```sh
 *  $ pulumi import aws:elasticache/replicationGroup:ReplicationGroup my_replication_group replication-group-1
 * ```
 */
class ReplicationGroup extends pulumi.CustomResource {
    constructor(name, argsOrState, opts) {
        let inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState;
            inputs["applyImmediately"] = state ? state.applyImmediately : undefined;
            inputs["arn"] = state ? state.arn : undefined;
            inputs["atRestEncryptionEnabled"] = state ? state.atRestEncryptionEnabled : undefined;
            inputs["authToken"] = state ? state.authToken : undefined;
            inputs["autoMinorVersionUpgrade"] = state ? state.autoMinorVersionUpgrade : undefined;
            inputs["automaticFailoverEnabled"] = state ? state.automaticFailoverEnabled : undefined;
            inputs["availabilityZones"] = state ? state.availabilityZones : undefined;
            inputs["clusterEnabled"] = state ? state.clusterEnabled : undefined;
            inputs["clusterMode"] = state ? state.clusterMode : undefined;
            inputs["configurationEndpointAddress"] = state ? state.configurationEndpointAddress : undefined;
            inputs["engine"] = state ? state.engine : undefined;
            inputs["engineVersion"] = state ? state.engineVersion : undefined;
            inputs["engineVersionActual"] = state ? state.engineVersionActual : undefined;
            inputs["finalSnapshotIdentifier"] = state ? state.finalSnapshotIdentifier : undefined;
            inputs["globalReplicationGroupId"] = state ? state.globalReplicationGroupId : undefined;
            inputs["kmsKeyId"] = state ? state.kmsKeyId : undefined;
            inputs["maintenanceWindow"] = state ? state.maintenanceWindow : undefined;
            inputs["memberClusters"] = state ? state.memberClusters : undefined;
            inputs["multiAzEnabled"] = state ? state.multiAzEnabled : undefined;
            inputs["nodeType"] = state ? state.nodeType : undefined;
            inputs["notificationTopicArn"] = state ? state.notificationTopicArn : undefined;
            inputs["numberCacheClusters"] = state ? state.numberCacheClusters : undefined;
            inputs["parameterGroupName"] = state ? state.parameterGroupName : undefined;
            inputs["port"] = state ? state.port : undefined;
            inputs["primaryEndpointAddress"] = state ? state.primaryEndpointAddress : undefined;
            inputs["readerEndpointAddress"] = state ? state.readerEndpointAddress : undefined;
            inputs["replicationGroupDescription"] = state ? state.replicationGroupDescription : undefined;
            inputs["replicationGroupId"] = state ? state.replicationGroupId : undefined;
            inputs["securityGroupIds"] = state ? state.securityGroupIds : undefined;
            inputs["securityGroupNames"] = state ? state.securityGroupNames : undefined;
            inputs["snapshotArns"] = state ? state.snapshotArns : undefined;
            inputs["snapshotName"] = state ? state.snapshotName : undefined;
            inputs["snapshotRetentionLimit"] = state ? state.snapshotRetentionLimit : undefined;
            inputs["snapshotWindow"] = state ? state.snapshotWindow : undefined;
            inputs["subnetGroupName"] = state ? state.subnetGroupName : undefined;
            inputs["tags"] = state ? state.tags : undefined;
            inputs["tagsAll"] = state ? state.tagsAll : undefined;
            inputs["transitEncryptionEnabled"] = state ? state.transitEncryptionEnabled : undefined;
        }
        else {
            const args = argsOrState;
            if ((!args || args.replicationGroupDescription === undefined) && !opts.urn) {
                throw new Error("Missing required property 'replicationGroupDescription'");
            }
            inputs["applyImmediately"] = args ? args.applyImmediately : undefined;
            inputs["atRestEncryptionEnabled"] = args ? args.atRestEncryptionEnabled : undefined;
            inputs["authToken"] = args ? args.authToken : undefined;
            inputs["autoMinorVersionUpgrade"] = args ? args.autoMinorVersionUpgrade : undefined;
            inputs["automaticFailoverEnabled"] = args ? args.automaticFailoverEnabled : undefined;
            inputs["availabilityZones"] = args ? args.availabilityZones : undefined;
            inputs["clusterMode"] = args ? args.clusterMode : undefined;
            inputs["engine"] = args ? args.engine : undefined;
            inputs["engineVersion"] = args ? args.engineVersion : undefined;
            inputs["finalSnapshotIdentifier"] = args ? args.finalSnapshotIdentifier : undefined;
            inputs["globalReplicationGroupId"] = args ? args.globalReplicationGroupId : undefined;
            inputs["kmsKeyId"] = args ? args.kmsKeyId : undefined;
            inputs["maintenanceWindow"] = args ? args.maintenanceWindow : undefined;
            inputs["multiAzEnabled"] = args ? args.multiAzEnabled : undefined;
            inputs["nodeType"] = args ? args.nodeType : undefined;
            inputs["notificationTopicArn"] = args ? args.notificationTopicArn : undefined;
            inputs["numberCacheClusters"] = args ? args.numberCacheClusters : undefined;
            inputs["parameterGroupName"] = args ? args.parameterGroupName : undefined;
            inputs["port"] = args ? args.port : undefined;
            inputs["replicationGroupDescription"] = args ? args.replicationGroupDescription : undefined;
            inputs["replicationGroupId"] = args ? args.replicationGroupId : undefined;
            inputs["securityGroupIds"] = args ? args.securityGroupIds : undefined;
            inputs["securityGroupNames"] = args ? args.securityGroupNames : undefined;
            inputs["snapshotArns"] = args ? args.snapshotArns : undefined;
            inputs["snapshotName"] = args ? args.snapshotName : undefined;
            inputs["snapshotRetentionLimit"] = args ? args.snapshotRetentionLimit : undefined;
            inputs["snapshotWindow"] = args ? args.snapshotWindow : undefined;
            inputs["subnetGroupName"] = args ? args.subnetGroupName : undefined;
            inputs["tags"] = args ? args.tags : undefined;
            inputs["transitEncryptionEnabled"] = args ? args.transitEncryptionEnabled : undefined;
            inputs["arn"] = undefined /*out*/;
            inputs["clusterEnabled"] = undefined /*out*/;
            inputs["configurationEndpointAddress"] = undefined /*out*/;
            inputs["engineVersionActual"] = undefined /*out*/;
            inputs["memberClusters"] = undefined /*out*/;
            inputs["primaryEndpointAddress"] = undefined /*out*/;
            inputs["readerEndpointAddress"] = undefined /*out*/;
            inputs["tagsAll"] = undefined /*out*/;
        }
        if (!opts.version) {
            opts = pulumi.mergeOptions(opts, { version: utilities.getVersion() });
        }
        super(ReplicationGroup.__pulumiType, name, inputs, opts);
    }
    /**
     * Get an existing ReplicationGroup resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    static get(name, id, state, opts) {
        return new ReplicationGroup(name, state, Object.assign(Object.assign({}, opts), { id: id }));
    }
    /**
     * Returns true if the given object is an instance of ReplicationGroup.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    static isInstance(obj) {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ReplicationGroup.__pulumiType;
    }
}
exports.ReplicationGroup = ReplicationGroup;
/** @internal */
ReplicationGroup.__pulumiType = 'aws:elasticache/replicationGroup:ReplicationGroup';
//# sourceMappingURL=replicationGroup.js.map