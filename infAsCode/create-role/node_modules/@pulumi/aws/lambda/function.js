"use strict";
// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
Object.defineProperty(exports, "__esModule", { value: true });
exports.Function = void 0;
const pulumi = require("@pulumi/pulumi");
const utilities = require("../utilities");
/**
 * Provides a Lambda Function resource. Lambda allows you to trigger execution of code in response to events in AWS, enabling serverless backend solutions. The Lambda Function itself includes source code and runtime configuration.
 *
 * For information about Lambda and how to use it, see [What is AWS Lambda?](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html)
 *
 * > To give an external source (like a CloudWatch Event Rule, SNS, or S3) permission to access the Lambda function, use the `aws.lambda.Permission` resource. See [Lambda ****Permission Model][4] for more details. On the other hand, the `role` argument of this resource is the function's execution role for identity and access to AWS services and resources.
 *
 * > **NOTE:** Due to [AWS Lambda improved VPC networking changes that began deploying in September 2019](https://aws.amazon.com/blogs/compute/announcing-improved-vpc-networking-for-aws-lambda-functions/), EC2 subnets and security groups associated with Lambda Functions can take up to 45 minutes to successfully delete.
 *
 * > To give an external source (like an EventBridge Rule, SNS, or S3) permission to access the Lambda function, use the `aws.lambda.Permission` resource. See [Lambda Permission Model](https://docs.aws.amazon.com/lambda/latest/dg/intro-permission-model.html) for more details. On the other hand, the `role` argument of this resource is the function's execution role for identity and access to AWS services and resources.
 *
 * ## Example Usage
 * ### Basic Example
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const iamForLambda = new aws.iam.Role("iamForLambda", {assumeRolePolicy: `{
 *   "Version": "2012-10-17",
 *   "Statement": [
 *     {
 *       "Action": "sts:AssumeRole",
 *       "Principal": {
 *         "Service": "lambda.amazonaws.com"
 *       },
 *       "Effect": "Allow",
 *       "Sid": ""
 *     }
 *   ]
 * }
 * `});
 * const testLambda = new aws.lambda.Function("testLambda", {
 *     code: new pulumi.asset.FileArchive("lambda_function_payload.zip"),
 *     role: iamForLambda.arn,
 *     handler: "index.test",
 *     runtime: "nodejs12.x",
 *     environment: {
 *         variables: {
 *             foo: "bar",
 *         },
 *     },
 * });
 * ```
 * ### Lambda Layers
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const exampleLayerVersion = new aws.lambda.LayerVersion("exampleLayerVersion", {});
 * // ... other configuration ...
 * const exampleFunction = new aws.lambda.Function("exampleFunction", {layers: [exampleLayerVersion.arn]});
 * ```
 * ### Lambda File Systems
 *
 * Lambda File Systems allow you to connect an Amazon Elastic File System (EFS) file system to a Lambda function to share data across function invocations, access existing data including large files, and save function state.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * // EFS file system
 * const efsForLambda = new aws.efs.FileSystem("efsForLambda", {tags: {
 *     Name: "efs_for_lambda",
 * }});
 * // Mount target connects the file system to the subnet
 * const alpha = new aws.efs.MountTarget("alpha", {
 *     fileSystemId: efsForLambda.id,
 *     subnetId: aws_subnet.subnet_for_lambda.id,
 *     securityGroups: [aws_security_group.sg_for_lambda.id],
 * });
 * // EFS access point used by lambda file system
 * const accessPointForLambda = new aws.efs.AccessPoint("accessPointForLambda", {
 *     fileSystemId: efsForLambda.id,
 *     rootDirectory: {
 *         path: "/lambda",
 *         creationInfo: {
 *             ownerGid: 1000,
 *             ownerUid: 1000,
 *             permissions: "777",
 *         },
 *     },
 *     posixUser: {
 *         gid: 1000,
 *         uid: 1000,
 *     },
 * });
 * // A lambda function connected to an EFS file system
 * // ... other configuration ...
 * const example = new aws.lambda.Function("example", {
 *     fileSystemConfig: {
 *         arn: accessPointForLambda.arn,
 *         localMountPath: "/mnt/efs",
 *     },
 *     vpcConfig: {
 *         subnetIds: [aws_subnet.subnet_for_lambda.id],
 *         securityGroupIds: [aws_security_group.sg_for_lambda.id],
 *     },
 * }, {
 *     dependsOn: [alpha],
 * });
 * ```
 * ### CloudWatch Logging and Permissions
 *
 * For more information about CloudWatch Logs for Lambda, see the [Lambda User Guide](https://docs.aws.amazon.com/lambda/latest/dg/monitoring-functions-logs.html).
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const config = new pulumi.Config();
 * const lambdaFunctionName = config.get("lambdaFunctionName") || "lambda_function_name";
 * // This is to optionally manage the CloudWatch Log Group for the Lambda Function.
 * // If skipping this resource configuration, also add "logs:CreateLogGroup" to the IAM policy below.
 * const example = new aws.cloudwatch.LogGroup("example", {retentionInDays: 14});
 * // See also the following AWS managed policy: AWSLambdaBasicExecutionRole
 * const lambdaLogging = new aws.iam.Policy("lambdaLogging", {
 *     path: "/",
 *     description: "IAM policy for logging from a lambda",
 *     policy: `{
 *   "Version": "2012-10-17",
 *   "Statement": [
 *     {
 *       "Action": [
 *         "logs:CreateLogGroup",
 *         "logs:CreateLogStream",
 *         "logs:PutLogEvents"
 *       ],
 *       "Resource": "arn:aws:logs:*:*:*",
 *       "Effect": "Allow"
 *     }
 *   ]
 * }
 * `,
 * });
 * const lambdaLogs = new aws.iam.RolePolicyAttachment("lambdaLogs", {
 *     role: aws_iam_role.iam_for_lambda.name,
 *     policyArn: lambdaLogging.arn,
 * });
 * const testLambda = new aws.lambda.Function("testLambda", {}, {
 *     dependsOn: [
 *         lambdaLogs,
 *         example,
 *     ],
 * });
 * ```
 * ### Lambda with Targetted Architecture
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const iamForLambda = new aws.iam.Role("iamForLambda", {assumeRolePolicy: `{
 *   "Version": "2012-10-17",
 *   "Statement": [
 *     {
 *       "Action": "sts:AssumeRole",
 *       "Principal": {
 *         "Service": "lambda.amazonaws.com"
 *       },
 *       "Effect": "Allow",
 *       "Sid": ""
 *     }
 *   ]
 * }
 * `});
 * const testLambda = new aws.lambda.Function("testLambda", {
 *     code: new pulumi.asset.FileArchive("lambda_function_payload.zip"),
 *     role: iamForLambda.arn,
 *     handler: "index.test",
 *     runtime: "nodejs12.x",
 *     architectures: ["arm64"],
 *     environment: {
 *         variables: {
 *             foo: "bar",
 *         },
 *     },
 * });
 * ```
 *
 * ## Import
 *
 * Lambda Functions can be imported using the `function_name`, e.g.,
 *
 * ```sh
 *  $ pulumi import aws:lambda/function:Function test_lambda my_test_lambda_function
 * ```
 */
class Function extends pulumi.CustomResource {
    constructor(name, argsOrState, opts) {
        let inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState;
            inputs["architectures"] = state ? state.architectures : undefined;
            inputs["arn"] = state ? state.arn : undefined;
            inputs["code"] = state ? state.code : undefined;
            inputs["codeSigningConfigArn"] = state ? state.codeSigningConfigArn : undefined;
            inputs["deadLetterConfig"] = state ? state.deadLetterConfig : undefined;
            inputs["description"] = state ? state.description : undefined;
            inputs["environment"] = state ? state.environment : undefined;
            inputs["fileSystemConfig"] = state ? state.fileSystemConfig : undefined;
            inputs["handler"] = state ? state.handler : undefined;
            inputs["imageConfig"] = state ? state.imageConfig : undefined;
            inputs["imageUri"] = state ? state.imageUri : undefined;
            inputs["invokeArn"] = state ? state.invokeArn : undefined;
            inputs["kmsKeyArn"] = state ? state.kmsKeyArn : undefined;
            inputs["lastModified"] = state ? state.lastModified : undefined;
            inputs["layers"] = state ? state.layers : undefined;
            inputs["memorySize"] = state ? state.memorySize : undefined;
            inputs["name"] = state ? state.name : undefined;
            inputs["packageType"] = state ? state.packageType : undefined;
            inputs["publish"] = state ? state.publish : undefined;
            inputs["qualifiedArn"] = state ? state.qualifiedArn : undefined;
            inputs["reservedConcurrentExecutions"] = state ? state.reservedConcurrentExecutions : undefined;
            inputs["role"] = state ? state.role : undefined;
            inputs["runtime"] = state ? state.runtime : undefined;
            inputs["s3Bucket"] = state ? state.s3Bucket : undefined;
            inputs["s3Key"] = state ? state.s3Key : undefined;
            inputs["s3ObjectVersion"] = state ? state.s3ObjectVersion : undefined;
            inputs["signingJobArn"] = state ? state.signingJobArn : undefined;
            inputs["signingProfileVersionArn"] = state ? state.signingProfileVersionArn : undefined;
            inputs["sourceCodeHash"] = state ? state.sourceCodeHash : undefined;
            inputs["sourceCodeSize"] = state ? state.sourceCodeSize : undefined;
            inputs["tags"] = state ? state.tags : undefined;
            inputs["tagsAll"] = state ? state.tagsAll : undefined;
            inputs["timeout"] = state ? state.timeout : undefined;
            inputs["tracingConfig"] = state ? state.tracingConfig : undefined;
            inputs["version"] = state ? state.version : undefined;
            inputs["vpcConfig"] = state ? state.vpcConfig : undefined;
        }
        else {
            const args = argsOrState;
            if ((!args || args.role === undefined) && !opts.urn) {
                throw new Error("Missing required property 'role'");
            }
            inputs["architectures"] = args ? args.architectures : undefined;
            inputs["code"] = args ? args.code : undefined;
            inputs["codeSigningConfigArn"] = args ? args.codeSigningConfigArn : undefined;
            inputs["deadLetterConfig"] = args ? args.deadLetterConfig : undefined;
            inputs["description"] = args ? args.description : undefined;
            inputs["environment"] = args ? args.environment : undefined;
            inputs["fileSystemConfig"] = args ? args.fileSystemConfig : undefined;
            inputs["handler"] = args ? args.handler : undefined;
            inputs["imageConfig"] = args ? args.imageConfig : undefined;
            inputs["imageUri"] = args ? args.imageUri : undefined;
            inputs["kmsKeyArn"] = args ? args.kmsKeyArn : undefined;
            inputs["layers"] = args ? args.layers : undefined;
            inputs["memorySize"] = args ? args.memorySize : undefined;
            inputs["name"] = args ? args.name : undefined;
            inputs["packageType"] = args ? args.packageType : undefined;
            inputs["publish"] = args ? args.publish : undefined;
            inputs["reservedConcurrentExecutions"] = args ? args.reservedConcurrentExecutions : undefined;
            inputs["role"] = args ? args.role : undefined;
            inputs["runtime"] = args ? args.runtime : undefined;
            inputs["s3Bucket"] = args ? args.s3Bucket : undefined;
            inputs["s3Key"] = args ? args.s3Key : undefined;
            inputs["s3ObjectVersion"] = args ? args.s3ObjectVersion : undefined;
            inputs["sourceCodeHash"] = args ? args.sourceCodeHash : undefined;
            inputs["tags"] = args ? args.tags : undefined;
            inputs["timeout"] = args ? args.timeout : undefined;
            inputs["tracingConfig"] = args ? args.tracingConfig : undefined;
            inputs["vpcConfig"] = args ? args.vpcConfig : undefined;
            inputs["arn"] = undefined /*out*/;
            inputs["invokeArn"] = undefined /*out*/;
            inputs["lastModified"] = undefined /*out*/;
            inputs["qualifiedArn"] = undefined /*out*/;
            inputs["signingJobArn"] = undefined /*out*/;
            inputs["signingProfileVersionArn"] = undefined /*out*/;
            inputs["sourceCodeSize"] = undefined /*out*/;
            inputs["tagsAll"] = undefined /*out*/;
            inputs["version"] = undefined /*out*/;
        }
        if (!opts.version) {
            opts = pulumi.mergeOptions(opts, { version: utilities.getVersion() });
        }
        super(Function.__pulumiType, name, inputs, opts);
    }
    /**
     * Get an existing Function resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    static get(name, id, state, opts) {
        return new Function(name, state, Object.assign(Object.assign({}, opts), { id: id }));
    }
    /**
     * Returns true if the given object is an instance of Function.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    static isInstance(obj) {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Function.__pulumiType;
    }
}
exports.Function = Function;
/** @internal */
Function.__pulumiType = 'aws:lambda/function:Function';
//# sourceMappingURL=function.js.map